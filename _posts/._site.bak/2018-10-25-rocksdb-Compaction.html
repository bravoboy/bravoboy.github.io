<ul id="markdown-toc">
  <li><a href="#背景" id="markdown-toc-背景">背景</a></li>
  <li><a href="#compact" id="markdown-toc-compact">Compact</a></li>
  <li><a href="#主要函数" id="markdown-toc-主要函数">主要函数</a></li>
  <li><a href="#效果" id="markdown-toc-效果">效果</a></li>
</ul>

<h2 id="背景">背景</h2>
<p>线上有一个集群，之前是没有开启ttl过期的，数据积累很多了，占用磁盘85%了，再增长下去非常危险。和业务方沟通以后可以删除30天以前的数据，只保留最近30天的数据，果断开启了ttl功能(会自动删除大于30天的数据)。开启以后，观察发现数据删除很慢，每天新增的数据比删除的数据还多，磁盘占用率还在上升。top -Hp命令发现一般只有一个rocksdb后台线程在compact工作。</p>

<h2 id="compact">Compact</h2>
<p>rocksdb中存在两种类型的compaction：minor compaction和major compaction。minor compaction是指的把内存中的immutable dump到L0的sst文件，一般我们也叫做flush。major compaction是指的L0以下的sst文件规整。</p>

<p>rocksdb里面有2种compaction策略: <a href="https://github.com/facebook/rocksdb/wiki/Universal-Compaction">Universal Compaction</a>和<a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">Leveled Compaction</a></p>

<h2 id="主要函数">主要函数</h2>
<p>compaction的调度都是MaybeScheduleFlushOrCompaction函数里面。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void DBImpl::MaybeScheduleFlushOrCompaction() {
  mutex_.AssertHeld();
  if (!opened_successfully_) {
    // Compaction may introduce data race to DB open
    return;
  }
  if (bg_work_paused_ &gt; 0) {
    // we paused the background work
    return;
  } else if (shutting_down_.load(std::memory_order_acquire)) {
    // DB is being deleted; no more background compactions
    return;
  }
  auto bg_job_limits = GetBGJobLimits();
  bool is_flush_pool_empty =
    env_-&gt;GetBackgroundThreads(Env::Priority::HIGH) == 0;
  while (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; 0 &amp;&amp;
         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) {
    unscheduled_flushes_--;
    bg_flush_scheduled_++;
    env_-&gt;Schedule(&amp;DBImpl::BGWorkFlush, this, Env::Priority::HIGH, this);
  }

  // special case -- if high-pri (flush) thread pool is empty, then schedule
  // flushes in low-pri (compaction) thread pool.
  if (is_flush_pool_empty) {
    while (unscheduled_flushes_ &gt; 0 &amp;&amp;
           bg_flush_scheduled_ + bg_compaction_scheduled_ &lt;
               bg_job_limits.max_flushes) {
      unscheduled_flushes_--;
      bg_flush_scheduled_++;
      env_-&gt;Schedule(&amp;DBImpl::BGWorkFlush, this, Env::Priority::LOW, this);
    }
  }

  if (bg_compaction_paused_ &gt; 0) {
    // we paused the background compaction
    return;
  }

  if (HasExclusiveManualCompaction()) {
    // only manual compactions are allowed to run. don't schedule automatic
    // compactions
    return;
  }

  while (bg_compaction_scheduled_ &lt; bg_job_limits.max_compactions &amp;&amp;
         unscheduled_compactions_ &gt; 0) {
    CompactionArg* ca = new CompactionArg;
    ca-&gt;db = this;
    ca-&gt;m = nullptr;
    bg_compaction_scheduled_++;
    unscheduled_compactions_--;
    env_-&gt;Schedule(&amp;DBImpl::BGWorkCompaction, ca, Env::Priority::LOW, this,
                   &amp;DBImpl::UnscheduleCallback);
  }
}
</code></pre></div></div>

<p>看上面代码知道：根据bg_job_limits限制来决定启动多少个线程去compaction。
GetBGJobLimits函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DBImpl::BGJobLimits DBImpl::GetBGJobLimits() const {
  mutex_.AssertHeld();
  return GetBGJobLimits(immutable_db_options_.max_background_flushes,
                        mutable_db_options_.max_background_compactions,
                        mutable_db_options_.max_background_jobs,
                        write_controller_.NeedSpeedupCompaction());
}

DBImpl::BGJobLimits DBImpl::GetBGJobLimits(int max_background_flushes,
                                           int max_background_compactions,
                                           int max_background_jobs,
                                           bool parallelize_compactions) {
  BGJobLimits res;
  if (max_background_flushes == -1 &amp;&amp; max_background_compactions == -1) {
    // for our first stab implementing max_background_jobs, simply allocate a
    // quarter of the threads to flushes.
    res.max_flushes = std::max(1, max_background_jobs / 4);
    res.max_compactions = std::max(1, max_background_jobs - res.max_flushes);
  } else {
    // compatibility code in case users haven't migrated to max_background_jobs,
    // which automatically computes flush/compaction limits
    res.max_flushes = std::max(1, max_background_flushes);
    res.max_compactions = std::max(1, max_background_compactions);
  }
  if (!parallelize_compactions) {
    // throttle background compactions until we deem necessary
    res.max_compactions = 1;
  }
  return res;
}
</code></pre></div></div>

<p>我们线上已经调整过max_background_compactions=20，但是GetBGJobLimits里面还是会设置max_compactions=1。
修改点：设置res.max_compactions = max_background_compactions</p>

<h2 id="效果">效果</h2>

<p>20分钟就把磁盘文件大小从3.2T降低到1.5T。 效果非常明显，不过这个也是有代价的，这20分钟时间内ioutil飙升到了100%。至此完成数据清理问题。</p>

